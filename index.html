<html>
	<head>
	    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	</head>
	<body bgcolor="#444444">
		<button id="submitFreeInput" >Load</button>
		<button id="mergeBtn">Merge</button>
		<button id="drawLinesBtn">ReDraw</button>
		<button id="LogLinesBtn">Log Lines</button>
		<button id="Special">Special</button>
		<button id="Fast">Fast</button>
		<button id="Step">Step</button>
		<button id="Real">Real</button>
		<button id="RealStep">RealStep</button>
		<button id="Test">Test</button>
		<br>
		<canvas id="myCanvas" style="border:1px solid #000000;"></canvas>
		<canvas id="myCanvas2" style="border:1px solid #000000;"></canvas>
		<br>
		<textarea id="freeInput" rows="20" cols="100">{
	        "id": "kristineberg,2600.0,1600.0,-700.0",
	        "vertices": "2650.93,1656.09,-684.9;2653.73,1656.03,-684.59;2657.72,1656.44,-684.04;2663.32,1657.42,-683.27;2664.83,1659.24,-683.06;2664.53,1660.44,-683.09;2661.26,1662.2,-683.53;2658.14,1664.1,-683.94;2659.07,1667.14,-683.0;2660.93,1670.49,-682.31;2661.39,1672.89,-682.41;2661.89,1675.23,-682.19;2663.35,1677.29,-682.25;2663.78,1678.97,-682.47;2664.17,1680.6,-682.38;2664.84,1681.83,-682.3;2665.55,1684.88,-682.3;2667.11,1686.87,-682.36;2667.99,1688.24,-682.11;2669.38,1692.02,-681.71;2670.74,1693.48,-681.64;2671.5,1694.59,-681.58;2672.44,1696.87,-680.67;2673.07,1697.6,-680.45;2674.84,1697.67,-680.0;2687.323538461538,1658.5121538461538,-680.0;2684.99,1658.33,-680.32;2681.38,1658.45,-680.81;2678.02,1658.1,-681.27;2675.94,1658.29,-681.55;2674.27,1660.45,-681.77;2672.29,1660.89,-682.03;2671.15,1661.96,-682.18;2669.76,1662.89,-682.37;2667.63,1665.05,-682.45;2667.06,1665.97,-682.46;2666.62,1667.75,-682.46;2666.44,1669.72,-682.46;2667.24,1672.11,-682.1;2668.53,1674.96,-682.11;2669.39,1676.05,-682.12;2670.5,1677.41,-682.12;2671.18,1678.56,-682.12;2673.89,1681.44,-682.09;2674.72,1682.78,-682.08;2676.79,1685.18,-682.05;2676.69,1686.57,-682.05;2678.31,1688.9,-681.97;2678.69,1690.3,-681.9;2679.61,1692.16,-680.9;2680.67,1695.52,-680.8;2679.61,1696.15,-680.54;2678.39,1696.72,-680.42;2677.539879518072,1697.3930120481928,-680.0;2669.014,1683.897,-682.946;2668.11,1684.8,-682.98;2600.0,1656.2131764705882,-692.5841176470587;2603.02,1656.0,-692.14;2606.26,1656.45,-691.65;2609.33,1656.56,-691.19;2612.41,1656.5,-690.73;2616.35,1656.54,-690.14;2619.99,1656.48,-689.6;2623.6,1656.74,-689.06;2627.69,1656.47,-688.45;2631.23,1657.33,-687.92;2635.27,1656.57,-687.32;2639.44,1656.53,-686.7;2643.61,1656.32,-686.08;2647.5,1655.97,-685.49;2650.96,1656.16,-684.98;2650.0,1648.41,-685.13;2650.98,1649.55,-684.98;2650.35,1650.37,-685.07;2649.74,1650.55,-685.16;2646.18,1650.64,-685.7;2642.92,1650.73,-686.18;2639.46,1650.81,-686.7;2635.95,1650.8,-687.22;2632.7,1650.81,-687.71;2628.66,1650.78,-688.31;2625.3,1650.61,-688.81;2622.15,1650.6,-689.28;2619.35,1650.45,-689.7;2616.12,1650.49,-690.18;2613.04,1650.47,-690.64;2610.35,1650.48,-691.05;2606.71,1650.29,-691.59;2603.43,1650.1,-692.08;2600.65,1649.76,-692.49;2600.0,1649.720606060606,-692.5884848484849;2687.59,1652.46,-680.0;2684.35,1652.44,-680.44;2680.87,1652.55,-680.91;2676.11,1651.96,-681.56;2672.88,1652.04,-682.0;2664.46,1651.54,-683.15;2661.05,1650.87,-684.9;2658.28,1650.32,-684.9;2657.46,1649.96,-684.9;2656.11,1648.11,-684.9;2656.14,1645.26,-684.9;2655.41,1641.56,-684.9;2653.45,1641.46,-684.9;2669.37,1684.96,-683.59;2670.755819,1684.385975,-683.59;2670.87,1684.96,-683.59;2670.755819,1685.534025,-683.59;2670.43066,1686.02066,-683.59;2669.944025,1686.345819,-683.59;2669.37,1686.46,-683.59;2668.795975,1686.345819,-683.59;2668.30934,1686.02066,-683.59;2667.984181,1685.534025,-683.59;2667.87,1684.96,-683.59;2667.984181,1684.385975,-683.59;2668.30934,1683.89934,-683.59;2668.795975,1683.574181,-683.59;2669.37,1683.46,-683.59;2669.944025,1683.574181,-683.59;2670.43066,1683.89934,-683.59;2741.77,1766.73,-685.0;2743.715287,1766.043299,-685.0;2743.83,1766.84,-685.0;2743.631097,1767.619955,-685.0;2743.148858,1768.264422,-685.0;2742.456701,1768.675287,-685.0;2741.66,1768.79,-685.0;2740.880045,1768.591097,-685.0;2740.235578,1768.108858,-685.0;2739.824713,1767.416701,-685.0;2739.71,1766.62,-685.0;2739.908903,1765.840045,-685.0;2740.391142,1765.195578,-685.0;2741.083299,1764.784713,-685.0;2741.88,1764.67,-685.0;2742.659955,1764.868903,-685.0;2743.304422,1765.351142,-685.0;2749.96,1754.07,-684.7;2750.052388,1754.031732,-684.7;2750.06,1754.07,-684.7;2750.052388,1754.108268,-684.7;2750.030711,1754.140711,-684.7;2749.998268,1754.162388,-684.7;2749.96,1754.17,-684.7;2749.921732,1754.162388,-684.7;2749.889289,1754.140711,-684.7;2749.867612,1754.108268,-684.7;2749.86,1754.07,-684.7;2749.867612,1754.031732,-684.7;2749.889289,1753.999289,-684.7;2749.921732,1753.977612,-684.7;2749.96,1753.97,-684.7;2749.998268,1753.977612,-684.7;2750.030711,1753.999289,-684.7;2750.66,1756.3,-684.7;2750.752388,1756.261732,-684.7;2750.76,1756.3,-684.7;2750.752388,1756.338268,-684.7;2750.730711,1756.370711,-684.7;2750.698268,1756.392388,-684.7;2750.66,1756.4,-684.7;2750.621732,1756.392388,-684.7;2750.589289,1756.370711,-684.7;2750.567612,1756.338268,-684.7;2750.56,1756.3,-684.7;2750.567612,1756.261732,-684.7;2750.589289,1756.229289,-684.7;2750.621732,1756.207612,-684.7;2750.66,1756.2,-684.7;2750.698268,1756.207612,-684.7;2750.730711,1756.229289,-684.7;2722.846891,1627.624715,-684.287098;2723.03,1629.61,-684.21;2721.96,1631.72,-684.22;2721.96,1637.28,-684.25;2722.51,1643.71,-684.29;2723.93,1650.88,-684.32;2725.36,1655.85,-684.34;2726.51,1659.92,-684.36;2728.41,1665.77,-684.38;2729.54,1670.09,-684.39;2730.66,1674.85,-684.41;2732.39,1679.96,-684.43;2733.91,1686.02,-684.45;2735.22,1690.22,-684.47;2736.4,1693.83,-684.48;2737.64,1699.27,-684.5;2738.92,1703.65,-684.52;2739.64,1706.93,-684.53;2740.47,1709.98,-684.55;2741.6,1711.28,-684.55;2744.5,1711.63,-684.55;2744.28,1714.6,-684.57;2744.59,1719.58,-684.58;2745.87,1722.69,-684.6;2744.87,1725.53,-684.6;2745.03,1728.86,-684.62;2746.21,1732.85,-684.63;2747.69,1736.92,-684.65;2749.12,1742.67,-684.67;2750.27,1746.46,-684.68;2752.64,1750.56,-684.7;2755.52,1754.62,-684.68;2758.39,1759.41,-684.66;2759.78,1761.14,-684.65;2762.21,1764.96,-684.64;2766.38,1769.02,-684.62;2772.25,1775.45,-684.6;2778.78,1781.47,-684.62;2781.33,1784.46,-684.62;2786.21,1789.15,-684.64;2792.29,1794.9,-684.65;2797.785848375451,1800.0,-684.6684115523466;2739.71,1766.79,-685.0;2738.39,1766.61,-684.7;2739.44,1764.0,-684.7;2739.39,1758.51,-684.7;2739.17,1750.46,-684.69;2739.27,1745.12,-684.67;2738.68,1740.32,-684.65;2738.17,1736.48,-684.64;2740.38,1735.19,-684.63;2741.52,1731.1,-684.62;2741.23,1727.44,-684.61;2740.46,1724.09,-684.59;2739.16,1719.25,-684.58;2737.88,1714.19,-684.56;2736.45,1709.92,-684.54;2735.51,1705.67,-684.53;2734.33,1701.52,-684.51;2732.42,1695.39,-684.49;2731.47,1692.13,-684.47;2729.95,1686.82,-684.45;2729.32,1684.02,-684.44;2728.58,1680.0,-684.43;2725.6,1670.38,-684.39;2724.4,1665.55,-684.37;2724.15,1664.02,-684.37;2720.0,1665.3,-684.37;2717.83,1661.79,-684.35;2722.24,1659.85,-684.35;2720.4,1656.64,-684.34;2718.95,1650.91,-684.32;2717.44,1647.2,-684.3;2714.74,1642.49,-684.27;2712.06,1639.68,-684.25;2711.43,1637.72,-684.24;2710.28,1635.43,-684.22;2706.73,1632.52,-684.24;2705.57,1631.11,-684.23;2704.15,1630.22,-684.23;2701.36,1628.4,-684.21;2697.48,1626.35,-684.19;2695.81,1624.87,-684.18;2693.63,1623.57,-684.17;2689.4,1622.0,-684.14;2687.89,1624.43,-683.94;2686.61,1626.71,-683.9;2684.37,1625.74,-683.9;2684.41,1624.04,-683.9;2685.82,1620.64,-683.99;2672.12,1607.84,-682.34;2669.55,1609.69,-684.02;2669.88,1611.4,-684.03;2671.07,1612.16,-684.03;2673.63,1612.68,-684.05;2675.31,1612.87,-684.06;2678.58,1613.26,-684.07;2682.92,1614.73,-684.1;2686.45,1614.95,-684.12;2689.63,1615.98,-684.13;2692.82,1617.97,-684.15;2695.73,1619.69,-684.17;2697.61,1620.84,-684.18;2699.61,1621.81,-684.2;2704.12,1625.26,-684.21;2705.74,1626.31,-684.22;2707.94,1628.35,-684.23;2711.18,1631.37,-684.2;2713.49,1632.24,-684.21;2714.61,1631.61,-684.21;2714.59,1630.08,-684.2;2713.674087,1626.797977,-684.179184;2743.24,1765.28,-685.0;2743.68,1764.68,-684.7;2743.79,1763.16,-684.7;2745.07,1762.35,-684.7;2745.97,1759.23,-684.7;2746.36,1757.45,-684.7;2746.22,1758.05,-684.7;2745.12,1756.63,-684.7;2746.54,1751.65,-684.7;2746.24,1750.59,-684.7;2746.15,1747.59,-684.7;2747.11,1747.29,-684.7;2748.2,1749.17,-684.7;2749.43,1752.63,-684.7;2749.43,1752.6,-684.7;2750.03,1753.32,-684.7;2792.981487179487,1800.0,-684.6605641025641;2790.8,1797.94,-684.65;2787.69,1795.03,-684.65;2783.39,1791.07,-684.64;2778.05,1785.54,-684.62;2773.26,1781.65,-684.61;2771.77,1780.22,-684.6;2769.86,1780.14,-684.6;2767.79,1778.0,-684.6;2765.04,1773.49,-684.61;2763.6,1771.77,-682.7;2761.59,1770.11,-682.7;2761.27,1768.82,-684.63;2759.53,1766.98,-684.64;2757.15,1763.75,-684.65;2751.21,1757.16,-685.01;2754.04,1757.98,-684.67;2756.19,1760.87,-684.66;2757.23,1763.83,-684.65;2638.91,1641.62,-687.2;2635.17,1639.56,-682.8;2632.68,1638.99,-682.73;2629.41,1638.62,-682.63;2626.51,1638.02,-682.6;2625.68,1636.44,-682.6;2627.12,1633.07,-682.6;2630.28,1629.83,-684.0;2629.61,1626.01,-684.0;2633.1,1624.86,-683.88;2634.04,1624.1,-683.84;2637.5,1622.72,-683.72;2641.45,1621.34,-683.58;2643.94,1620.26,-683.49;2646.26,1619.48,-683.4;2648.17,1618.24,-683.33;2647.85,1617.12,-683.32;2646.3,1616.15,-683.35;2640.08,1615.61,-683.86;2637.99,1615.96,-683.85;2685.8,1620.63,-685.0;2684.53,1619.87,-684.11;2680.67,1619.17,-684.09;2678.79,1619.01,-684.08;2676.02,1618.38,-684.07;2674.01,1618.27,-684.06;2673.34,1620.89,-684.06;2670.32,1621.03,-684.04;2669.57,1618.2,-684.03;2665.53,1617.17,-682.8;2661.54,1617.23,-682.91;2659.27,1618.87,-683.0;2656.29,1620.97,-683.13;2652.42,1622.1,-683.26;2650.46,1623.21,-683.34;2649.27,1623.71,-683.38;2646.97,1625.15,-683.47;2645.34,1625.7,-683.53;2644.3,1626.79,-683.58;2641.6,1627.64,-683.67;2638.64,1629.38,-683.79;2636.25,1630.46,-683.88;2631.79,1632.71,-684.0;2629.81,1633.03,-682.6;2628.99,1634.24,-682.6;2630.05,1635.49,-682.61;2633.46,1635.92,-682.71;2639.0,1636.35,-682.87;2643.06,1636.51,-682.98;2645.15,1635.15,-683.02;2647.89,1635.42,-683.1;2648.28,1639.92,-683.16;2639.06,1610.63,-683.85;2642.56,1610.85,-683.87;2646.75,1611.02,-683.9;2650.54,1611.39,-683.92;2654.27,1611.46,-683.94;2656.46,1611.52,-683.98;2658.06,1610.63,-683.98;2659.09,1609.19,-683.98;2658.82,1607.08,-683.97;2657.31,1603.49,-683.96;2655.72,1600.84,-683.94;2655.348932038835,1600.0,-683.94;2661.44540533751,1600.0,-683.9456756043852;2662.12,1601.28,-683.95;2663.58,1604.05,-683.97;2666.07,1604.9,-683.97;2667.9,1604.37,-683.97;2669.84,1603.4,-683.19;2672.18,1607.8,-682.3;2674.57,1606.61,-682.3;2677.09,1605.89,-682.3;2669.84,1603.4,-683.18;2672.03,1602.31,-682.3;2675.11,1601.03,-682.3;2763.68,1771.7,-682.7;2761.61,1770.09,-682.7;2669.4,1683.500003,-683.40283;2669.4,1683.5000027846363,-700.0",
	        "faces": "0,1@0;1,2@0;2,3@0;3,4@0;4,5@0;5,6@0;6,7@0;7,8@0;8,9@0;9,10@0;10,11@0;11,12@0;12,13@0;13,14@0;14,15@0;15,16@0;16,17@0;17,18@0;18,19@0;19,20@0;20,21@0;21,22@0;22,23@0;23,24@0;25,26@0;26,27@0;27,28@0;28,29@0;29,30@0;30,31@0;31,32@0;32,33@0;33,34@0;34,35@0;35,36@0;36,37@0;37,38@0;38,39@0;39,40@0;40,41@0;41,42@0;42,43@0;43,44@0;44,45@0;45,46@0;46,47@0;47,48@0;48,49@0;49,50@0;50,51@0;51,52@0;52,53@0;56,57@0;57,58@0;58,59@0;59,60@0;60,61@0;61,62@0;62,63@0;63,64@0;64,65@0;65,66@0;66,67@0;67,68@0;68,69@0;69,70@0;71,72@0;72,73@0;73,74@0;74,75@0;75,76@0;76,77@0;77,78@0;78,79@0;79,80@0;80,81@0;81,82@0;82,83@0;83,84@0;84,85@0;85,86@0;86,87@0;87,88@0;88,89@0;89,90@0;91,92@0;92,93@0;93,94@0;94,95@0;95,96@0;96,97@0;97,98@0;98,99@0;99,100@0;100,101@0;101,102@0;102,103@0;104,105,106@0;104,106,107@0;104,107,108@0;104,108,109@0;104,109,110@0;104,110,111@0;104,111,112@0;104,112,113@0;104,113,114@0;104,114,115@0;104,115,116@0;104,116,117@0;104,117,118@0;104,118,119@0;104,119,120@0;104,120,105@0;121,122,123@0;121,123,124@0;121,124,125@0;121,125,126@0;121,126,127@0;121,127,128@0;121,128,129@0;121,129,130@0;121,130,131@0;121,131,132@0;121,132,133@0;121,133,134@0;121,134,135@0;121,135,136@0;121,136,137@0;121,137,122@0;138,139,140@0;138,140,141@0;138,141,142@0;138,142,143@0;138,143,144@0;138,144,145@0;138,145,146@0;138,146,147@0;138,147,148@0;138,148,149@0;138,149,150@0;138,150,151@0;138,151,152@0;138,152,153@0;138,153,154@0;138,154,139@0;155,156,157@0;155,157,158@0;155,158,159@0;155,159,160@0;155,160,161@0;155,161,162@0;155,162,163@0;155,163,164@0;155,164,165@0;155,165,166@0;155,166,167@0;155,167,168@0;155,168,169@0;155,169,170@0;155,170,171@0;155,171,156@0;172,173@0;173,174@0;174,175@0;175,176@0;176,177@0;177,178@0;178,179@0;179,180@0;180,181@0;181,182@0;182,183@0;183,184@0;184,185@0;185,186@0;186,187@0;187,188@0;188,189@0;189,190@0;190,191@0;191,192@0;192,193@0;193,194@0;194,195@0;195,196@0;196,197@0;197,198@0;198,199@0;199,200@0;200,201@0;201,202@0;202,203@0;203,204@0;204,205@0;205,206@0;206,207@0;207,208@0;208,209@0;209,210@0;210,211@0;211,212@0;212,213@0;214,215@0;215,216@0;216,217@0;217,218@0;218,219@0;219,220@0;220,221@0;221,222@0;222,223@0;223,224@0;224,225@0;225,226@0;226,227@0;227,228@0;228,229@0;229,230@0;230,231@0;231,232@0;232,233@0;233,234@0;234,235@0;235,236@0;236,237@0;237,238@0;238,239@0;239,240@0;240,241@0;241,242@0;242,243@0;243,244@0;244,245@0;245,246@0;246,247@0;247,248@0;248,249@0;249,250@0;250,251@0;251,252@0;252,253@0;253,254@0;254,255@0;255,256@0;256,257@0;257,258@0;258,259@0;259,260@0;260,261@0;262,263@0;263,264@0;264,265@0;265,266@0;266,267@0;267,268@0;268,269@0;269,270@0;270,271@0;271,272@0;272,273@0;273,274@0;274,275@0;275,276@0;276,277@0;277,278@0;278,279@0;279,280@0;280,281@0;281,282@0;282,283@0;284,285@0;285,286@0;286,287@0;287,288@0;288,289@0;290,291@0;291,292@0;293,294@0;294,295@0;295,296@0;296,297@0;298,299@0;300,301@0;301,302@0;302,303@0;303,304@0;304,305@0;305,306@0;306,307@0;307,308@0;308,309@0;309,310@0;311,312@0;312,313@0;313,314@0;315,316@0;316,317@0;317,318@0;319,320@0;320,321@0;321,322@0;322,323@0;323,324@0;324,325@0;325,326@0;326,327@0;327,328@0;328,329@0;329,330@0;330,331@0;331,332@0;332,333@0;333,334@0;334,335@0;335,336@0;336,337@0;337,338@0;339,340@0;340,341@0;341,342@0;342,343@0;343,344@0;344,345@0;345,346@0;346,347@0;347,348@0;348,349@0;349,350@0;350,351@0;351,352@0;352,353@0;353,354@0;354,355@0;355,356@0;356,357@0;357,358@0;358,359@0;359,360@0;360,361@0;361,362@0;362,363@0;363,364@0;364,365@0;365,366@0;366,367@0;367,368@0;368,369@0;369,370@0;371,372@0;372,373@0;373,374@0;374,375@0;375,376@0;376,377@0;377,378@0;378,379@0;379,380@0;380,381@0;381,382@0;383,384@0;384,385@0;385,386@0;386,387@0;387,388@0;389,390@0;390,391@0;392,393@0;393,394@0;395,396@0",
	        "boundingBox": {
	            "min": [
	            2600,
	            1600,
	            -700
	           ],
	           "max": [
	            2800,
	            1800,
	            -680
	           ]
	         }
    	}</textarea>
	</body>

	<script src="js-priority-queue/priority-queue.js"></script>


	<script>
 		//54,55@0;;397,398@0

		const canvasWidth = 1000;
		const canvasHeight = 1000;
		const $canvas = $("#myCanvas");
		const $canvas2 = $("#myCanvas2");
		const canvas = $canvas[0];
		const canvas2 = $canvas2[0];

		// $canvas.width(canvasWidth).height(canvasHeight);
		// $canvas2.width(canvasWidth).height(canvasHeight);

		canvas.width = canvasWidth;
		canvas.height = canvasHeight;
		canvas2.width = canvasWidth;
		canvas2.height = canvasHeight;

		const c1 = canvas.getContext("2d");

		const c2 = canvas2.getContext("2d");


//Grabbing the "negative" X value will always give the appropriate sided X. Since the sites have a specified ordered in the tuple and the equation flipped upside down if sites are flipped.
		const myIntersect = 0;

		var lines = [];

		var numBP = 1;
		var numArch = 1;
		var numSite = 1;
		var dotSize = 3;


		c1.fillStyle = "#ffffff";
		c1.fillRect(0, 0, canvas.width, canvas.height);
		c2.fillStyle = "#ffffff";
		c2.fillRect(0, 0, canvas.width, canvas.height);

		function Edge (originX, originY, twin)
		{
			this.originX = originX;
			this.originY = originY;
			this.twin = twin;
		}

		function Site(x, y)
		{
			this.x = x;
			this.y = y;
			this.siteID = numSite++;
		}

		function CircleEvent(x,y, eventY, arch)
		{
			this.x = x;
			this.y = y;
			this.eventY = eventY;
			this.falseAlarm = false;
			this.dissapearingArch = arch;

		}

		function compareEvents(a, b)
		{
			return a.y - b.y;
		}


		function BeachTree(queue)
		{
			this.root = null;
			this.edges = [];
			this.queue = queue;
		}

		BeachTree.prototype.addSite = function(site)
		{
			if(!site instanceof Site)
			{
				throw "Invalid Argument, not of instance Site"
			}
			// if(isNaN(site.y))
			// 	console.log("Bleeh")
			// console.log(site.x, site.y);
			if(this.root == null)
			{
				let arch = new Arch(site);
				this.root = arch;
			}
			else {
				if(this.root instanceof Arch)
				{
					this.root = splitArch(this.root, site, null, this.queue);
				}
				else
				{
					this.root.addSite(site, null);
				}
			}
		}

		function decFunc(bp, rightSide)
		{
			return function()
			{
				if(rightSide)
					bp.rightHeight--;
				else
					bp.leftHeight--;
			}
		}

		BeachTree.prototype.processCircle = function(circleEvent)
		{
			if(!this.root instanceof Breakpoint)
			{
				throw "Attempted to remove arch from BeachTree without breakpoints";
				return;
			}
			let tryLog = function() {if(log) console.log.apply(console, arguments)}
			let log = false;

			// if(circleEvent.dissapearingArch.archID == 647)
			// 	log = true;

			let lastNode = null;
			let currentNode = this.root;
			let firstBP = null;
			let sndBP = null;

			let arch = circleEvent.dissapearingArch;
			let leftArch = arch.before;
			let rightArch = arch.after;

			tryLog("Circle tripplet %d %d %d", leftArch.archID, arch.archID, rightArch.archID);

			let lastRight = false;
			funcList = [];
			//Find both involved breakpoints
			while(sndBP == null)
			{
				if(!(currentNode instanceof Breakpoint))
				{
					console.log("Circle tripplet %d %d %d", leftArch.archID, arch.archID, rightArch.archID);
					throw "Diddn't find breakpoints for circleEvent"
					return;
				}
				tryLog("Searching through ", currentNode.bpID);
				if(currentNode.tuple[0] == leftArch && currentNode.tuple[1] == arch)
				{
					if(firstBP == null)
					{
						firstBP = currentNode;
						lastNode = currentNode;
						if(currentNode.leftHeight >= currentNode.rightHeight)
							funcList = [];
						funcList.push(decFunc(currentNode, true));
						currentNode = currentNode.rightChild;
						lastRight = true;

					}
					else
					{
						sndBP = currentNode;
					}
				}
				else if(currentNode.tuple[0] == arch && currentNode.tuple[1] == rightArch)
				{
					if(firstBP == null)
					{
						tryLog("Found first")
						firstBP = currentNode;
						lastNode = currentNode;
						if(currentNode.rightHeight >= currentNode.leftHeight)
							funcList = [];
						funcList.push(decFunc(currentNode, false));0
						currentNode = currentNode.leftChild;
						lastRight = false;
					}
					else
					{
						tryLog("Found second");
						sndBP = currentNode;
					}
				}
				else
				{
					lastNode = currentNode;
					let breakX = currentNode.breakX(circleEvent.y, log);
					tryLog("BreakX %f EventX %f", breakX, circleEvent.x);
					if(circleEvent.x == breakX)
					{
						throw "Event on top of breakpoint, undefined behaviour!"
					}
					else if(circleEvent.x > breakX)
					{
						if(currentNode.leftHeight >= currentNode.rightHeight)
							funcList = [];
						funcList.push(decFunc(currentNode, true));
						currentNode = currentNode.rightChild;
						lastRight = true;
					}
					else
					{
						if(currentNode.rightHeight >= currentNode.leftHeight)
							funcList = [];
						funcList.push(decFunc(currentNode, false));
						currentNode = currentNode.leftChild;
						lastRight = false;
					}
				}
			}
			//Found both!
			let sndOtherNode = (sndBP.rightChild == arch? sndBP.leftChild : sndBP.rightChild);
			if(lastRight)
			{
				if(lastNode.leftHeight < lastNode.rightHeight)
				{
					for (func of funcList)
						func();
				}
				else
				{
					lastNode.rightHeight--;
				}
				lastNode.rightChild = sndOtherNode;
			}
			else
			{
				if(lastNode.rightHeight < lastNode.leftHeight)
				{
					for (func of funcList)
						func();
				}
				else
				{
					lastNode.leftHeight--;
				}
				lastNode.leftChild = sndOtherNode;
			}

			if(this.root.getHeight()-1 != (this.root.leftHeight>this.root.rightHeight? this.root.leftHeight: this.root.rightHeight))
			{
				console.error("Height error! Got %d, have %d and %d", this.root.getHeight()-1, this.root.leftHeight, this.root.rightHeight)
				console.log("While processing tripple %d %d %d", leftArch.archID, arch.archID, rightArch.archID);
			}
			leftArch.after = rightArch;
			rightArch.before = leftArch;

			firstEdge = firstBP.edge;
			sndEdge = sndBP.edge;

			sndEdge.originX = circleEvent.x;
			sndEdge.originY = circleEvent.eventY;
			firstEdge.originX = circleEvent.x;
			firstEdge.originY = circleEvent.eventY;

			if(sndEdge.twin.originX != null)
			{
				this.edges.push(sndEdge);
			}
			if(firstEdge.twin.originX != null)
			{
				this.edges.push(firstEdge);
			}

			twinEdge = new Edge(circleEvent.x, circleEvent.eventY, null);
			newEdge = new Edge(null, null, twinEdge);
			twinEdge.twin = newEdge;
			this.edges.push(twinEdge);

			firstBP.tuple = [leftArch, rightArch];
			firstBP.edge = newEdge;

			if(leftArch.circleEvent != null)
			{
				leftArch.circleEvent.falseAlarm = true;
				leftArch.circleEvent = null;
				//console.log("nullify left on remove")
			}
			if(rightArch.circleEvent != null)
			{
				rightArch.circleEvent.falseAlarm = true;
				rightArch.circleEvent = null;
				//console.log("nullify right on remove")
			}

			if(leftArch.before != null)
			{
				let event = detectCircleEvent(leftArch.before, leftArch, rightArch);
				if(event != null)
				{
					//console.log("left circle on remove")
					leftArch.circleEvent = event;
					this.queue.queue(event);
				}
			}
			if(rightArch.after != null)
			{
				let event = detectCircleEvent(leftArch, rightArch, rightArch.after);
				if(event != null)
				{
					//console.log("right circle on remove");
					rightArch.circleEvent = event;
					this.queue.queue(event);
				}
			}
		}

		BeachTree.prototype.deepRemove = function(circleEvent)
		{
			if(this.root != null)
			{
				let leftArch = circleEvent.dissapearingArch.before;
				let rightArch = circleEvent.dissapearingArch.after;
				console.log("Dissapearing tripple %d %d %d", leftArch.archID, circleEvent.dissapearingArch.archID, rightArch.archID);
				let res = this.root.deepRemove(circleEvent, leftArch, rightArch, false);
				if(!res[0])
				{
					throw "Failed to deep remove!"
				}
				for(edge of res[2])
				{
					this.edges.push(edge);
				}
			}
		}

		BeachTree.prototype.draw = function(line, hCorrecter, wCorrecter, arches)
		{
			if(this.root != null)
			{
				this.root.draw(line, hCorrecter, wCorrecter, arches);
				c1.strokeStyle = "#ff0000"
				for (edge of this.edges)
				{
					//console.log(edge);
					if(edge.twin.originX != null)
					{
						c1.beginPath();
						c1.moveTo(wCorrecter(edge.originX), hCorrecter(edge.originY));
						c1.lineTo(wCorrecter(edge.twin.originX), hCorrecter(edge.twin.originY));
						c1.stroke();
					}
				}
			}
		}
		BeachTree.prototype.print = function(line)
		{
			if(this.root != null)
			{
				c2.fillStyle = "#ffffff";
				c2.fillRect(0, 0, canvas.width, canvas.height);

				this.root.print(0, canvas.width, 40);
			}
		}

		function BeachNode(){}

		function Breakpoint(leftArch, rightArch, leftChild, rightChild, isRightSide, edge, queue)
		{
			this.edge = edge;
			this.tuple = [leftArch, rightArch];
			this.leftChild = leftChild;
			this.rightChild = rightChild;
			this.isRightSide = isRightSide;
			this.bpID = numBP++;
			this.queue = queue;
			this.leftHeight = 1;
			this.rightHeight = 1;
		}

		function Arch(site)
		{
			this.site = site;
			this.circleEvent = null;
			this.before = null;
			this.after = null;
			this.archID = numArch++;
		}

		Breakpoint.prototype = Object.create(BeachNode.prototype);
		Arch.prototype = Object.create(BeachNode.prototype);

		function floatToBits(f)
		{
		    var buf = new ArrayBuffer(4);
		    (new Float32Array(buf))[0] = f;
		    return (new Uint32Array(buf))[0];
		}

		function bitsToFloat(b) {
		    var buf = new ArrayBuffer(4);
		    (new Uint32Array(buf))[0] = b;
		    return (new Float32Array(buf))[0];
		}

		function nextFloat(f) {
		    // Note that this moves away from 0.0
		    // It will fail at +/- infinity and result in an NaN
		    var bitRepr = floatToBits(f);
		    bitRepr++;
		    return bitsToFloat(bitRepr);
		}
		function prevFloat(f) {
			// Note that this moves towards 0.0
			// This will fail at 0.0 and result in an NaN
			var bitRepr = floatToBits(f);
			bitRepr--;
			return bitsToFloat(bitRepr);
		}

		function findArchIntersect(leftSite, rightSite, line, log)
		{
			if(log) console.log("arch intersecet param ", leftSite, rightSite, line)
			if(leftSite.y == line || rightSite.y == line)
			{
				if(log) console.log("line on site. Increment");
				line = nextFloat(line);
			}
			if(line < leftSite.y || line < rightSite.y)
			{
				console.error("Line is smaller than both sites!");
				line = nextFloat((rightSite.y>leftSite.y? rightSite.y:leftSite.y));
			}
			let a = leftSite.x;
			let b = leftSite.y;
			let c = rightSite.x;
			let d = rightSite.y;
			let l = line;

			if(b == d)
			{
				console.log("B and D same.")
				d = nextFloat(d);
			}

			if(log) console.log(a,b,c,d,l);
			let squarePart = Math.sqrt(Math.pow((2*c)/(2*d - 2*l) - (2*a)/(2*b - 2*l), 2) - 4*(1/(2*b - 2*l) - 1/(2*d - 2*l)) * (Math.pow(a,2)/(2*b - 2*l) + Math.pow(b,2)/(2*b - 2*l) - Math.pow(l, 2)/(2*b - 2*l) - Math.pow(c, 2)/(2*d - 2*l) - Math.pow(d, 2)/(2*d - 2*l) + Math.pow(l, 2)/(2*d - 2*l)));
			let posX = (squarePart + (2*a)/(2*b - 2*l) - (2*c)/(2*d - 2*l))/(2*(1/(2*b - 2*l) - 1/(2*d - 2*l)));
			let negX = (-squarePart + (2*a)/(2*b - 2*l) - (2*c)/(2*d - 2*l))/(2*(1/(2*b - 2*l) - 1/(2*d - 2*l)));
			if(log) console.log(squarePart, posX, negX);
			return[negX, posX];
			// Wolfram code
			// Solve[(a^2 + b^2 - l^2 - 2 a x + x^2)/(2 b - 2 l) == (c^2 + d^2 - l^2 - 2 c x + x^2)/(2 d - 2 l), x]

		}

		Breakpoint.prototype.getHeight = function()
		{
			let left;
			let right;
			if(this.leftChild instanceof Arch)
				left = 1;
			else left = this.leftChild.getHeight();
			if(this.rightChild instanceof Arch)
				right = 1;
			else right = this.rightChild.getHeight();
			return (left > right? left:right)+1;
		}

		Breakpoint.prototype.breakX = function(line, log = false)
		{
			return findArchIntersect(this.tuple[0].site, this.tuple[1].site, line, log)[myIntersect];
		}

		Breakpoint.prototype.deepRemove = function(circleEvent, leftArch, rightArch, firstFound)
		{
			console.log("BP ", this.bpID);
			let found = false;
			let rightSide = false;
			if(this.tuple[0] == leftArch && this.tuple[1] == circleEvent.dissapearingArch)
			{
				found = true;
				rightSide = false;
			}
			else if (this.tuple[0] == circleEvent.dissapearingArch && this.tuple[1] == rightArch)
			{
				found = true;
				rightSide = true;

			}
			let oldEdge = [];
			if(found)
			{
				this.edge.originX = circleEvent.x;
				this.edge.originY = circleEvent.eventY;
				if(this.edge.twin.originX == null)
					oldEdge.push(this.edge);
				if(!firstFound)
				{
					twinEdge = new Edge(circleEvent.x, circleEvent.eventY, null);
					newEdge = new Edge(null, null, twinEdge);
					twinEdge.twin = newEdge;
					this.edge = newEdge;
					oldEdge.push(twinEdge);
				}

			}
			if(found && firstFound)
			{
				//false flag old event on left and right
				//find new events for left and right.
				leftArch.after = rightArch;
				rightArch.before = leftArch;
				if(leftArch.before != null)
				{
					let event = detectCircleEvent(leftArch.before, leftArch, rightArch);
					if(event != null)
					{
						leftArch.circleEvent = event;
						this.queue.queue(event);
					}
				}
				if(rightArch.after != null)
				{
					let event = detectCircleEvent(leftArch, rightArch, rightArch.after);
					if(event != null)
					{
						rightArch.circleEvent = event;
						this.queue.queue(event);
					}
				}

				console.log("Found snd at BP ", this.bpID);
				return (rightSide ? this.rightChild: this.leftChild);
			}
			else
			{
				if(found)
				{
					this.tuple = [leftArch, rightArch];
				}


				let leftRes = this.leftChild.deepRemove(circleEvent, leftArch, rightArch, found || firstFound);
				let rightRes = this.rightChild.deepRemove(circleEvent, leftArch, rightArch, found || firstFound);

				//console.log("resses BP %d.\n %o %o,", this.bpID, leftRes, rightRes);

				let decreased = false;
				let recFound = false;
				let rightFound = false;
				let newArray = [];
				if(leftRes instanceof BeachNode)
				{
					console.log("Found direct left BP ", this.bpID);
					rightFound = false;
					recFound = true;
					this.leftChild = leftRes;
					if(this.leftHeight > this.rightHeight) decreased = true;
					this.leftHeight = 1;
				}
				else if(rightRes instanceof BeachNode)
				{
					console.log("Found direct right BP ", this.bpID);
					rightFound = true;
					recFound = true;
					this.rightChild = rightRes;
					if(this.leftHeight < this.rightHeight) decreased = true;
					this.rightHeight = 1;
				}
				else if(leftRes[0] == true)
				{
					console.log("Found rec left BP ", this.bpID);
					rightFound = false;
					recFound = true;
					newArray = leftRes[2];
					if(leftRes[1] == true)
					{
						if(this.leftHeight > this.rightHeight) decreased = true;
						this.leftHeight--;
					}
				}
				else if(rightRes[0] == true)
				{
					console.log("Found rec right BP ", this.bpID);
					rightFound = true;
					recFound = true;
					newArray = rightRes[2];
					if(rightRes[1] == true)
					{
						if(this.leftHeight < this.rightHeight) decreased = true;
						this.rightHeight--;
					}
				}

				newArray.push(...oldEdge);
				if(recFound)
				{
					//console.log("trying to return BP ", this.bpID, [recFound, decreased, newArray]);
					return [recFound, decreased, newArray];
				}
				else return [false, false, newArray];
			}

		}

		Arch.prototype.deepRemove = function()
		{
			return [false,false,[]];
		}

		Breakpoint.prototype.addSite = function(site, rightBP)
		{
			let breakpointX = this.breakX(site.y); //Grabbing the "negative" X value will always give the appropriate sided X. Since the sites have a specified ordered in the tuple the positive X will be on the left side in left side breakpoints, and vice versa for right.
			let goingRight = site.x > breakpointX;
			let child = (goingRight? this.rightChild: this.leftChild);
			if(child instanceof Arch)
			{
				if(goingRight){
					newBreak = splitArch(child, site, rightBP, this.queue);
					this.rightChild = newBreak;
					this.rightHeight = 3;
				}
				else
				{
					newBreak = splitArch(child, site, this, this.queue);
					this.leftChild = newBreak;
					this.leftHeight = 3;
				}
			}
			else
			{
				let height = child.addSite(site, (goingRight? rightBP: this)) + 1;
				if (goingRight) this.rightHeight = height;
				else this.leftHeight = height;
			}
			return (this.rightHeight > this.leftHeight? this.rightHeight: this.leftHeight);
		}

		Breakpoint.prototype.draw = function(line, hCorrecter, wCorrecter, arches)
		{
			let intersect = this.breakX(line);
			let index = (this.isRightSide? 1: 0);
			let invIndex = (this.isRightSide? 0: 1);
			let startB;

			if(this.edge.twin.originX != null)
			{
				startB = [this.edge.twin.originX, this.edge.twin.originY];
			}
			else
			{
				startB = [this.tuple[invIndex].site.x, this.tuple[index].site.getY(this.tuple[invIndex].site.y, this.tuple[invIndex].site.x)];
			}

			let b = [intersect, this.tuple[0].site.getY(line, intersect)];

			c1.fillStyle = "#FF0000";

			c1.beginPath();
			c1.arc(wCorrecter(b[0]), hCorrecter(b[1]), dotSize, 0, 2 * Math.PI, false);
			c1.fill();

			c1.strokeStyle = "#ff0000";
			c1.beginPath();
			c1.moveTo(wCorrecter(b[0]), hCorrecter(b[1]));
			c1.lineTo(wCorrecter(startB[0]), hCorrecter(startB[1]));
			c1.stroke();

			this.leftChild.draw(line, hCorrecter, wCorrecter, arches);
			this.rightChild.draw(line, hCorrecter, wCorrecter, arches);
		}
		Breakpoint.prototype.print = function(start, end, height)
		{
			stdHeightDiff = 50;
			botToAr = 35;
			ArToTxt = 20;
			c2.fillStyle = "#FF0000";
			c2.font = "12px Arial";
			c2.textAlign = "center"
			let mid = start + (end-start)/2;
			c2.fillText(this.bpID, mid, height);
			c2.fillStyle = "#0000FF";
			c2.fillText(this.tuple[0].archID+","+this.tuple[1].archID, mid, height+15)
			c2.fillText(this.leftHeight + " h " + this.rightHeight, mid, height + 30)

			let ratio = this.leftHeight/(this.leftHeight+this.rightHeight);
			let leftPartition = (end-start) * ratio;

			c2.strokeStyle = "#000000";
			c2.beginPath();
			c2.moveTo(mid, height+botToAr);
			c2.lineTo(start + (leftPartition)/2, height+stdHeightDiff);
			c2.stroke();

			c2.beginPath();
			c2.moveTo(mid, height+botToAr);
			c2.lineTo(start+leftPartition + (end-(start+leftPartition))/2, height+stdHeightDiff);
			c2.stroke();

			this.leftChild.print(start, start+leftPartition, height+stdHeightDiff+ArToTxt);
			this.rightChild.print(start+leftPartition, end, height+stdHeightDiff+ArToTxt);
		}

		Arch.prototype.print = function(start, end, height)
		{
			c2.fillStyle = "#0000FF";
			c2.font = "12px Arial";
			c2.textAlign = "center"
			let mid = start + (end-start)/2;
			c2.fillText(this.archID, mid, height);
			c2.fillStyle = "#00BB00";
			c2.fillText(this.site.siteID, mid, height+15);
			c2.fillStyle = "#FF0000";
		}

		Arch.prototype.draw = function(line, hCorrecter, wCorrecter, arches)
		{
			if(!arches) return;
			if(this.site.y == line)
				line = nextFloat(line);

			let tupX = this.site.getZeroX(line);
			let midY = this.site.getMidY(line);

			let cpx = 2 * this.site.x - tupX[0]/2 - tupX[1]/2;
			let cpy = 2 * midY;

			c1.strokeStyle = "rgba(0,0,0,0.3)";

			c1.beginPath();
			c1.moveTo(wCorrecter(tupX[0]), hCorrecter(0));
			c1.quadraticCurveTo(wCorrecter(cpx), hCorrecter(cpy), wCorrecter(tupX[1]), hCorrecter(0));
			c1.stroke();

		}

		function Line(offset, slope)
		{
			this.offset = offset;
			this.slope = slope;
		}

		Line.prototype.getX = function (y)
		{
			return (y-this.offset)/this.slope;
		}
		Line.prototype.getY = function (x)
		{
			return this.offset+this.slope*x;
		}

		function findLine(leftSite, rightSite)
		{
			let bigY = (leftSite.y > rightSite.y? leftSite.y : rightSite.y);
			p1X = findArchIntersect(leftSite, rightSite, bigY+1)[myIntersect];
			p2X = findArchIntersect(leftSite, rightSite, bigY+2)[myIntersect];

			p1Y = leftSite.getY(bigY+1, p1X);
			p2Y = leftSite.getY(bigY+2, p2X);

			if(p2X == p1X)
			{
				throw "Vertical line. Undefined!"
			}

			slope = (p2Y-p1Y)/(p2X-p1X);
			offset = p1Y - slope*p1X;

			return new Line(offset, slope);
		}

		function findLineIntersect(leftSite, midSite, rightSite, log = false)
		{
			tryLog = function() {if(log) console.log.apply(console, arguments)}
			tryLog("ID's %d %d %d", leftSite.siteID, midSite.siteID, rightSite.siteID);
			tryLog("(%f, %f) (%f, %f) (%f, %f)", leftSite.x, leftSite.y, midSite.x, midSite.y, rightSite.x, rightSite.y)

			let v1 = [midSite.x - leftSite.x, midSite.y - leftSite.y];
			let v2 = [rightSite.x - midSite.x, rightSite.y - midSite.y];

			if((rightSite.x == midSite.x) && rightSite.y == midSite.y)
			console.log("the same!");
			else tryLog("not same");

			tryLog("v1 (%f, %f) v2 (%f, %f)", v1[0], v1[1], v2[0], v2[1]);

			det = v1[0]*v2[1] - v1[1]*v2[0];

			if(det <= 0)
			{
				tryLog("Cross is zero or less. Points are on a line or diverging")
				return null; //Not right turn, not converging
			}

			// let thing = (midSite.x - leftSite.x)*(rightSite.y - leftSite.y) - (midSite.y-leftSite.y)*(rightSite.x - leftSite.x);
			// if(thing >= 0)
			// {
			// 	tryLog("Left or parallel")
			// 	return null;
			// }

			leftLine = findLine(leftSite, midSite);
			rightLine = findLine(midSite, rightSite);

			// if(leftLine.slope == rightLine.slope)
			// 	{
			// 		tryLog("Parallel lines");
			// 		return null;
			// 	}

			meetingX = (rightLine.offset - leftLine.offset)/(leftLine.slope - rightLine.slope);
			meetingY = leftLine.getY(meetingX);

			return [meetingX, meetingY];
		}

		function detectCircleEvent(leftArch, midArch, rightArch, log = false)
		{
			let meeting = findLineIntersect(leftArch.site, midArch.site, rightArch.site, log);
			if (meeting != null)
			{splitArch
				let pointToEvent = [meeting[0]-midArch.site.x, meeting[1]-midArch.site.y];
				let pteMag = Math.sqrt(Math.pow(pointToEvent[0],2)+Math.pow(pointToEvent[1],2));
				let event = new CircleEvent(meeting[0], meeting[1]+pteMag, meeting[1], midArch);
				return event;
			}
			else return null;
		}

		function splitArch(oldArch, newSite, farRightBP, queue)
		{
			let log = false;
			let tryLog = function(text)
			{
				if(log)
					console.log(text);
			}
			// if(newSite.siteID == 45)
			// {
			// 	console.log("yaas!");
			// 	log = true;
			// }
			if(oldArch.circleEvent != null)
			{
				oldArch.circleEvent.falseAlarm = true;
				oldArch.circleEvent = null;
			}
			var e1 = new Edge(null, null, null);
			var e2 = new Edge(null, null, e1);
			e1.twin = e2;

			let leftArch = oldArch;
			let midArch = new Arch(newSite);
			let rightArch = new Arch(oldArch.site);
			if(farRightBP)
				farRightBP.tuple[0] = rightArch;

			rightArch.before = midArch;
			rightArch.after = leftArch.after;
			if(rightArch.after != null)
				rightArch.after.before = rightArch;

			midArch.before = leftArch;
			midArch.after = rightArch;

			leftArch.after = midArch;

			//detect circleEvent
			let farLeftArch = leftArch.before;
			let farRightArch = rightArch.after;

			if(farLeftArch != null)
			{
				let event = detectCircleEvent(farLeftArch, leftArch, midArch, log);
				if(event != null)
				{
					leftArch.circleEvent = event;
					queue.queue(event);
					tryLog("Left circle on add");
				}
				else tryLog("No left circle")
			} else tryLog("No farLeft");
			if(farRightArch != null)
			{
				let event = detectCircleEvent(midArch, rightArch, farRightArch, log);
				if(event != null)
				{
					rightArch.circleEvent = event;
					queue.queue(event);
					tryLog("right circle on add");
				}
				else tryLog("No right circle")
			} else tryLog("No far right");

			leftBP = new Breakpoint(leftArch, midArch, leftArch, null, false, e2, queue);
			rightBP = new Breakpoint(midArch, rightArch, midArch, rightArch, true, e1, queue);
			leftBP.rightChild = rightBP;
			leftBP.rightHeight = 2;

			return leftBP;
		}

		Site.prototype.getZeroX = function(line)
		{
			if(this.y == line)
				line = nextFloat(line);
			a = this.x;
			b = this.y;
			l = line;
			squarePart = Math.sqrt((4*Math.pow(a,2))/Math.pow(2*b - 2*l,2) - (4*(Math.pow(a,2)/(2*b - 2*l) + Math.pow(b,2)/(2*b - 2*l) -Math.pow(l,2)/(2*b - 2*l)))/(2*b - 2*l));
			posX = (1/2)*(2*b - 2*l)*((2*a)/(2*b - 2*l) + squarePart);
			negX = (1/2)*(2*b - 2*l)*((2*a)/(2*b - 2*l) - squarePart);

			return [negX, posX];
		}

		Site.prototype.getMidY = function (line)
		{
			if(this.y == line)
				line = nextFloat(line);
			a = this.x;
			b = this.y;
			x = a;
			l = line;

			return (1/(2*(b-l)))*(Math.pow(x,2)-2*a*x+Math.pow(a,2)+Math.pow(b,2)-Math.pow(l,2));
		}

		Site.prototype.getY = function (line, x)
		{
			if(this.y == line)
				line = nextFloat(line);
			a = this.x;
			b = this.y;
			l = line;

			return (1/(2*(b-l)))*(Math.pow(x,2)-2*a*x+Math.pow(a,2)+Math.pow(b,2)-Math.pow(l,2));
		}

		function testSites(){
			site1 = new Site(300, 200);
			site2 = new Site(400, 400);
			site3 = new Site(500, 450);
			site4 = new Site(200, 550);
			site5 = new Site(299, 600);
			site6 = new Site(100, 700);
			site7 = new Site(700, 100);
			site8 = new Site(345, 654);
			site9 = new Site(213, 432);
			site10 = new Site(43, 143);
			return [site1, site2, site3, site4, site5, site6, site7, site8, site9, site10];
		}

		function properSites()
		{
			/*let json;
			try{
				json = JSON.parse($("#freeInput").val());
			}
			catch (e) {
				if (e instanceof SyntaxError) {
					alert("Invalid json");
					console.error(e);
				} else {
					alert(e);
				}
				return;
			}
			verticesGroup = json.vertices;
			verticesGroup = verticesGroup.split(";");
			sites = []
			for (group of verticesGroup)
			{
				divved = group.split(",");
				sites.push(new Site(parseFloat(divved[0]), parseFloat(divved[1])));
			}
			*/

			let vertFaces = getVertsFaces();
			sites = [];
			verts = vertFaces[0];
			for(face of vertFaces[1])
			{
				if(face.length == 2)
				{
					x1 = parseFloat(verts[face[0]][0]);
					y1 = parseFloat(verts[face[0]][1]);
					x2 = parseFloat(verts[face[1]][0]);
					y2 = parseFloat(verts[face[1]][1]);
					sites.push(new Site(x1, y1));
					sites.push(new Site(x2, y2));
				}
			}

			var queue = new PriorityQueue({ initialValues: sites, comparator: compareEvents });
			cleanSites = [];
			lastSite = [queue.dequeue()];
			while(queue.length > 0)
			{
				site = queue.dequeue();
				let discard = false;
				if(site.y == lastSite[0].y)
				{
					for(old of lastSite)
					{
						if(site.x == old.x)
						{
							discard = true;
							break;
						}
					}
				}
				else lastSite = []
				if(discard)
					console.log("discarded duplicate")
				else
				{
					cleanSites.push(site);
					lastSite.push(site);
				}
			}
			console.log(cleanSites.length)
			return cleanSites;
		}

		function getMinMax()
		{
			let json;
			try{
				json = JSON.parse($("#freeInput").val());
			}
			catch (e) {
				if (e instanceof SyntaxError) {
					alert("Invalid json");
					console.error(e);
				} else {
					alert(e);
				}
				return;
			}
			minX = json.boundingBox.min[0];
			minY = json.boundingBox.min[1];
			maxX = json.boundingBox.max[0];
			maxY = json.boundingBox.max[1];

			return [[minX, maxX], [minY, maxY]];
		}

		function bigRealArguments()
		{
			let minmax = getMinMax();
			let minX = minmax[0][0];
			let maxX = minmax[0][1];
			let minY = minmax[1][0];
			let maxY = minmax[1][1];

			let sites = properSites();
			let xMapper = makeMapper(minX-1, maxX+1, 0, maxX * 10);
			let yMapper = makeMapper(minY-1, maxY+1, 0, maxY * 10);
			bigSites = sites.map(s => new Site(xMapper(s.x), yMapper(s.y)));

			//heightCoef = (canvas.height / (maxY-minY)) * 0.95;
			//widthCoef = (canvas.width / (maxX-minX)) * 0.95;
			heightBuff = canvas.height * 0.025;
			widthBuff = canvas.width * 0.025;

			heightCoef = (canvas.height / (maxY * 10)) * 0.95;
			widthCoef = (canvas.width / (maxX * 10)) * 0.95;

			return [[bigSites], [makeCoordCorrecter(heightCoef, heightBuff, 0), makeCoordCorrecter(widthCoef, widthBuff, 0), 0, maxY*10]];
		}

		$("#Real").click(function()
		{
			args = bigRealArguments();
			voronoi.apply(this, args[0].concat([true, false]).concat(args[1]));
			//func =
//			voronoi(bigSites, true, false, makeCoordCorrecter(heightCoef, heightBuff, 0), makeCoordCorrecter(widthCoef, widthBuff, 0), 0, maxY*10);
			//$("#Real").off("click").click(func);
		});

		$("#RealStep").click(function()
		{
			args = bigRealArguments();
			func = voronoi.apply(this, args[0].concat([false, true]).concat(args[1]));
//			voronoi(bigSites, true, false, makeCoordCorrecter(heightCoef, heightBuff, 0), makeCoordCorrecter(widthCoef, widthBuff, 0), 0, maxY*10);
			$("#RealStep").off("click").click(func);

			for(let i = 0; i < 936; i++)
			{
				$("#RealStep").click();
			}
		});

		function makeMapper(a, b, c, d)
		{
			if(a == b)
				throw "Zero distance map between " + a + " and " + b
			return function(x)
			{
				let res = (x-a)/(b-a) * (d-c) + c
			//	if(isNaN(res))
			//	console.log("%f mapped to %f (%s)", x, res, res);
				return res;
			}
		}

		function makeCoordCorrecter(coef, buff, offset)
		{
			return function(coord)
			{
				return (coord-offset) * coef + buff;
			}
		}

		$("#Test").click(function()
		{
			let s1 = new Site(5,3);
			let s2 = new Site(3,2);

			let l = findLine(s1, s2);
			console.log(l);

			let s3 = new Site(2,0)
			let l2 = findLine(s2, s3);
			console.log(l2);
		});

		var k = 0;

		function voronoi(sites, draw, step, hCorrecter, wCorrecter, minY, maxY)
		{
			var queue = new PriorityQueue({ initialValues: sites, comparator: compareEvents });
			let start = null;
			let tree = new BeachTree(queue);
			let totTime = 10000;
			let restorePoint;
			let line = minY;
			let siteID = 1;
			let vertices = [];

			let firstEvent = queue.dequeue();
			if(firstEvent.y == queue.peek().y)
				firstEvent.y = prevFloat(firstEvent.y);
			queue.queue(firstEvent);

			newDraw = function (timestep)
			{
				if(!start)
				{
					start = timestep;
					c1.fillStyle = "#ffffff";
					c1.fillRect(0, 0, canvas.width, canvas.height);
					for(point of sites)
					{
						c1.fillStyle = "#000000";
						c1.beginPath();
						c1.arc(wCorrecter(point.x), hCorrecter(point.y), dotSize, 0, 2 * Math.PI, false);
						c1.fill();
					}
					restorePoint = c1.getImageData(0, 0, canvas.width, canvas.height);
				}
				let shouldStep = true;
				c1.putImageData(restorePoint, 0, 0);
				while(queue.length > 0 && ((queue.peek().y <= line && !step) || (step && shouldStep)))
				{1
					let event = queue.dequeue();
					if(step)
					{
						line = event.y;
					}
					if(event instanceof Site)
					{
						k++;
						event.siteID = siteID++;
							tree.addSite(event);

						tree.print();
					}
					else if(!event.falseAlarm)
					{
						k++;
						try
						{
							tree.processCircle(event);
						}
						catch
						{
							console.error("failed removal")
							console.log(k);
						}
						//tree.deepRemove(event);
						tree.print();
						vertices.push([event.x, event.eventY]);

						//Mid
						// c1.fillStyle = "#0000FF";
						// c1.beginPath();
						// c1.arc(wCorrecter(event.x), hCorrecter(event.eventY), dotSize, 0, 2 * Math.PI, false);
						// c1.fill();
						//
						// restorePoint = c1.getImageData(0, 0, canvas.width, canvas.height);
					}
					else
					{
						continue;
					}
					shouldStep = false;
				}
				if(step && shouldStep)
				{
					line = maxY
				}

				tree.draw(line, hCorrecter, wCorrecter, false);

				c1.strokeStyle = "#ff0000";
				c1.beginPath();
				c1.moveTo(0, hCorrecter(line));
				c1.lineTo(canvas.width, hCorrecter(line));
				c1.stroke();

				if(draw){
					timeDiff = timestep - start;
					line = minY + (maxY-minY) * (timeDiff/totTime)
					if(timeDiff < totTime)
					{
						window.requestAnimationFrame(newDraw);
					}
					else if(queue.length > 0)
					{
						line = queue.peek().y;
						window.requestAnimationFrame(newDraw);
					}
				}

				// if((draw || step) && queue.length == 0)
				// {
				// 	console.log("last draw")
				// 	c1.putImageData(restorePoint, 0, 0);
				// 	tree.draw(line, hCorrecter, wCorrecter, false);
				// }
			};
			if(draw)
				window.requestAnimationFrame(newDraw);
			else if(step)
			{
				newDraw();
				return newDraw;
			}
			else
			{
				while(queue.length > 0)
				{
					let event = queue.dequeue();
					if(event instanceof Site)
						tree.addSite(event);
					else if(!event.falseAlarm)
					{
						try
						{
							tree.processCircle(event);
						}
						catch
						{
							console.error("Failed removal")
						}
						vertices.push([event.x, event.eventY]);
					}
				}
				tree.print();
				return [vertices, tree.edges];
			}
		}

		$("#Special").click(function(){
			mapper = makeMapper(0, 800, 0, 1400);
			coef = 800/1400;
			sites = testSites();
/*			for (site of sites)
			{
				console.log("From %d %d", site.x, site.y);
				site.x = mapper(site.x);
				site.y = mapper(site.y);
				console.log("To %d %d", site.x, site.y);
			}*/
			voronoi(sites, true, false, makeCoordCorrecter(0.5, 0, -400), makeCoordCorrecter(0.5 ,0, -400), 0, 1400);
		});

		$("#Fast").click(function(){
			let minmax = getMinMax();
			let minX = minmax[0][0];
			let maxX = minmax[0][1];
			let minY = minmax[1][0];
			let maxY = minmax[1][1];

			let sites = properSites();
			let xMapper = makeMapper(minX-1, maxX+1, 0, maxX * 10);
			let yMapper = makeMapper(minY-1, maxY+1, 0, maxY * 10);
			bigSites = sites.map(s => new Site(xMapper(s.x), yMapper(s.y)));

			heightBuff = canvas.height * 0.025;
			widthBuff = canvas.width * 0.025;

			heightCoef = (canvas.height / (maxY * 10)) * 0.95;
			widthCoef = (canvas.width / (maxX * 10)) * 0.95;

			res = voronoi(bigSites, false, false, null, null, null, null, null);


			let hCorr = makeCoordCorrecter(heightCoef, heightBuff, 0);
			let wCorr = makeCoordCorrecter(widthCoef, widthBuff, 0);
			c1.fillStyle = "#ffffff";
			c1.fillRect(0, 0, canvas.width, canvas.height);

			if(false)
			{
				c1.fillStyle = "#0000FF";
				for(vert of res[0])
				{
					c1.beginPath();
					c1.arc(wCorr(vert[0]), hCorr(vert[1]), dotSize, 0, 2 * Math.PI, false);
					c1.fill();
				}
			}
			if(true)
			{
				c1.strokeStyle = "#FF0000";
				for(edge of res[1])
				{
					if(edge.twin.originX != null)
					{
						c1.beginPath();
						c1.moveTo(wCorr(edge.originX), hCorr(edge.originY));
						c1.lineTo(wCorr(edge.twin.originX), hCorr(edge.twin.originY));
						c1.stroke();
					}
				}
			}
			overlayMap();
		});

		$("#Step").click(function(){
			func = voronoi(testSites(), false, true, makeCoordCorrecter(0.5, 0, -800), makeCoordCorrecter(0.5 ,0, -400), 0, 2*canvas.height);
			$("#Step").off("click").click(func);
		});

		function vertexEdge(startID, startEdge, endID, endEdge)
		{
			this.startID = startID;
			this.startEdge = startEdge;
			this.endID = endID;
			this.endEdge = endEdge;
		}

		function vertexLine(startEdge, endEdge, ID)
		{
			this.startEdge = startEdge;
			this.endEdge = endEdge;

			this.numEdges = 1;
			this.ID = ID;
		}

		function mergeLines(first, second)
		{
			if(first.startEdge.startID == second.endEdge.endID)
			{
				second.endEdge.endEdge = first.startEdge; 	//Connect ends
				first.startEdge.startEdge = second.endEdge;	//Connect ends
				first.startEdge = second.startEdge;			//Take over start
				first.numEdges += second.numEdges;
			}
			else if(first.endEdge.endID == second.startEdge.startID)
			{
				second.startEdge.startEdge = first.endEdge; //Connect ends
				first.endEdge.endEdge = second.startEdge;	//Connect ends
				first.endEdge = second.endEdge;				//Take over end
				first.numEdges += second.numEdges;
			}
			else if(first.startEdge.startID == second.startEdge.startID)
			{
				proc = second.startEdge;
				prev = first.startEdge
				while(proc != null)
				{
					ve = new vertexEdge(proc.endID, null, proc.startID, prev);
					prev.startEdge = ve;
					first.startEdge = ve;
					first.numEdges++;

					prev = ve;
					proc = proc.endEdge;
				}
			}
			else if(first.endEdge.endID == second.endEdge.endID)
			{
				proc = second.endEdge;
				prev = first.endEdge
				while(proc != null)
				{
					ve = new vertexEdge(proc.endID, prev, proc.startID, null);
					prev.endEdge = ve;
					first.endEdge = ve;
					first.numEdges++;

					prev = ve;
					proc = proc.startEdge;
				}
			}
			else {
				console.error("Error in merging!");
			}
		}

		function drawLines()
		{

			c2.fillStyle = "#ffffff";
			c2.fillRect(0, 0, canvas.width, canvas.height);


			cols = ["#ff9d00", "#fff200", "#83ff00", "#00ffd4", "#00b2ff", "#0400ff", "#ae00ff", "#ff00a1", "#000000", "#7a2e00", "#ffa5a5", "#7c7b61"];
			for(var i = 0; i < lines.length; i++)
			{
				c2.strokeStyle = cols[i%cols.length];
				proc = lines[i].startEdge
				while(proc != null)
				{
					v1x = vertices[proc.startID][0]- minX;
					v1y = vertices[proc.startID][1]- minY;
					v2x = vertices[proc.endID][0]- minX;
					v2y = vertices[proc.endID][1]- minY;


					c2.beginPath();
					c2.moveTo(v1x * widthCoef + widthBuff, v1y * heightCoef + heightBuff);
					c2.lineTo(v2x * widthCoef + widthBuff, v2y * heightCoef + heightBuff);
					c2.stroke();

					proc = proc.endEdge;
				}
			}
		}

		function getVertsFaces()
		{
			let json;
			try{
				json = JSON.parse($("#freeInput").val());
			}
			catch (e) {
			    if (e instanceof SyntaxError) {
			        alert("Invalid json");
					console.error(e);
			    } else {
			        alert(e);
			    }
				return;
			}
			if((!json.boundingBox) || (!json.faces) || (!json.vertices))
			{
				console.error("Invalid mine map");
				return;
			}

			dirtyFaces = json.faces.split(";");
			cleanFaces = [];
			for(df of dirtyFaces)
			{
				cleanUnsplitSuffix = df.split("@");
				cleanFaces.push(cleanUnsplitSuffix[0].split(","));
			}
			verticesGroup = json.vertices;
			verticesGroup = verticesGroup.split(";");
			vertices = []
			for (group of verticesGroup)
			{
				vertices.push(group.split(","))
			}

			return [vertices, cleanFaces];
		}

		function overlayMap()
		{
			let vertFaces = getVertsFaces();
			let minmax = getMinMax();
			let minX = minmax[0][0];
			let maxX = minmax[0][1];
			let minY = minmax[1][0];
			let maxY = minmax[1][1];

			heightCoef = (canvas.height / (maxY-minY)) * 0.95;
			widthCoef = (canvas.width / (maxX-minX)) * 0.95;
			heightBuff = canvas.height * 0.025;
			widthBuff = canvas.width * 0.025;

			let xCorr = makeCoordCorrecter(widthCoef, widthBuff, minX);
			let yCorr = makeCoordCorrecter(heightCoef, heightBuff, minY);

			vertices = vertFaces[0];
			faces = vertFaces[1];

			c1.strokeStyle = "#000000";
			c1.fillStyle = "#ffb33a";

			for(face of faces)
			{
				if (face.length == 2)
				{
					v1x = vertices[face[0]][0];
					v1y = vertices[face[0]][1];
					v2x = vertices[face[1]][0];
					v2y = vertices[face[1]][1];

					c1.beginPath();
					c1.moveTo(xCorr(v1x), yCorr(v1y));
					c1.lineTo(xCorr(v2x), yCorr(v2y));
					c1.stroke();
				}
				else if (face.length == 3)
				{
					continue;
					v1x = vertices[face[0]][0];
					v1y = vertices[face[0]][1];
					v2x = vertices[face[1]][0];
					v2y = vertices[face[1]][1];
					v3x = vertices[face[2]][0];
					v3y = vertices[face[2]][1];


					c1.beginPath();
					c1.moveTo(xCorr(v1x), yCorr(v1y));
					c1.lineTo(xCorr(v2x), yCorr(v2y));
					c1.lineTo(xCorr(v3x), yCorr(v3y));
					c1.fill();

				}
			}


		}

		$("#submitFreeInput").click(function()
		{
			c1.fillStyle = "#ffffff";
			c1.fillRect(0, 0, canvas.width, canvas.height);

			let json;
			try{
				json = JSON.parse($("#freeInput").val());
			}
			catch (e) {
			    if (e instanceof SyntaxError) {
			        alert("Invalid json");
					console.error(e);
			    } else {
			        alert(e);
			    }
				return;
			}
			if((!json.boundingBox) || (!json.faces) || (!json.vertices))
			{
				console.error("Invalid mine map");
				return;
			}
			minX = json.boundingBox.min[0];
			minY = json.boundingBox.min[1];
			maxX = json.boundingBox.max[0];
			maxY = json.boundingBox.max[1];

			heightCoef = (canvas.height / (maxY-minY)) * 0.95;
			widthCoef = (canvas.width / (maxX-minX)) * 0.95;
			heightBuff = canvas.height * 0.025;
			widthBuff = canvas.width * 0.025;

			let xCorr = makeCoordCorrecter(widthCoef, widthBuff, minX);
			let yCorr = makeCoordCorrecter(heightCoef, heightBuff, minY);

			dirtyFaces = json.faces.split(";");
			cleanFaces = [];
			for(df of dirtyFaces)
			{
				cleanUnsplitSuffix = df.split("@");
				cleanFaces.push(cleanUnsplitSuffix[0].split(","));
			}
			verticesGroup = json.vertices;
			verticesGroup = verticesGroup.split(";");
			vertices = []
			for (group of verticesGroup)
			{
				vertices.push(group.split(","))
			}
			for(index of cleanFaces)
			{
				if (index.length == 2)
				{
					v1x = vertices[index[0]][0];
					v1y = vertices[index[0]][1];
					v2x = vertices[index[1]][0];
					v2y = vertices[index[1]][1];

					c1.beginPath();
					c1.moveTo(xCorr(v1x), yCorr(v1y));
					c1.lineTo(xCorr(v2x), yCorr(v2y));
					c1.stroke();
				}
				else if (index.length == 3)
				{
					c1.fillStyle = "#ffb33a";
					v1x = vertices[index[0]][0];
					v1y = vertices[index[0]][1];
					v2x = vertices[index[1]][0];
					v2y = vertices[index[1]][1];
					v3x = vertices[index[2]][0];
					v3y = vertices[index[2]][1];


					c1.beginPath();
					c1.moveTo(xCorr(v1x), yCorr(v1y));
					c1.lineTo(xCorr(v2x), yCorr(v2y));
					c1.lineTo(xCorr(v3x), yCorr(v3y));
					c1.fill();

				}
			}

			IDs = 0;
			for(index of cleanFaces)
			{
				if (index.length == 2)
				{
					found = false;
					foundAt = null;
					for(line of lines)
					{
						foundHere = false;
						if(line.startEdge.startID == index[0])
						{
							ve = new vertexEdge(index[1], null, index[0], line.startEdge);
							line.startEdge.startEdge = ve;
							line.startEdge = ve;
							line.numEdges++;
							foundHere = true;
						}
						else if(line.startEdge.startID == index[1])
						{
							ve = new vertexEdge(index[0], null, index[1], line.startEdge);
							line.startEdge.startEdge = ve;
							line.startEdge = ve;
							line.numEdges++;
							foundHere = true;
						}
						else if(line.endEdge.endID == index[0])
						{
							ve = new vertexEdge(index[0], line.endEdge, index[1], null);
							line.endEdge.endEdge = ve;
							line.endEdge = ve;
							line.numEdges++;
							foundHere = true;
						}
						else if(line.endEdge.endID == index[1])
						{
							ve = new vertexEdge(index[1], line.endEdge, index[0], null);
							line.endEdge.endEdge = ve;
							line.endEdge = ve;
							line.numEdges++;
							foundHere = true;
						}
						if (found && foundHere)
						{
							mergeLines(foundAt, lines);
							index = lines.indexOf(line);				//find redundant
							lines.splice(index, 1);						//Remove redundant
						}
						else if(foundHere)
						{
							foundAt = line;
							found = true;
						}
					}
					if(found == false)
					{
						ve = new vertexEdge(index[0], null, index[1], null);
						vl = new vertexLine(ve, ve, IDs++);
						lines.push(vl);
					}
				}
			}
			drawLines();

		});

		$("#mergeBtn").click(function()
		{
			while(lines.length > 1)
			{
				first = null;
				second = null;
				firstStart = false;
				secondStart = false;
				smallestDist = Number.MAX_VALUE;
				for (var i = 0; i < lines.length-1; i++)
				{
					for(var j = i+1; j < lines.length; j++)
					{
						fsx = vertices[lines[i].startEdge.startID][0];
						fsy = vertices[lines[i].startEdge.startID][1];
						fex = vertices[lines[i].endEdge.endID][0];
						fey = vertices[lines[i].endEdge.endID][1];

						ssx = vertices[lines[j].startEdge.startID][0];
						ssy = vertices[lines[j].startEdge.startID][1];
						sex = vertices[lines[j].endEdge.endID][0];
						sey = vertices[lines[j].endEdge.endID][1];

						SS = Math.sqrt(Math.pow(fsx - ssx, 2) + Math.pow(fsy - ssy, 2));
						SE = Math.sqrt(Math.pow(fsx - sex, 2) + Math.pow(fsy - sey, 2));
						ES = Math.sqrt(Math.pow(fex - ssx, 2) + Math.pow(fey - ssy, 2));
						EE = Math.sqrt(Math.pow(fex - sex, 2) + Math.pow(fey - sey, 2));

						smaller = false;
						if (SS < smallestDist)
						{
							smaller = true
							smallestDist = SS;
							firstStart = true;
							secondStart = true;
						}
						if(SE < smallestDist)
						{
							smaller = true
							smallestDist = SE;
							firstStart = true;
							secondStart = false;
						}
						if(ES < smallestDist)
						{
							smaller = true
							smallestDist = ES;
							firstStart = false;
							secondStart = true;
						}
						if(EE < smallestDist)
						{
							smaller = true
							smallestDist = EE;
							firstStart = false;
							secondStart = false;
						}
						if(smaller == true)
						{
							first = lines[i];
							second = lines[j];
						}
					}
				}
				var ve;
				if(firstStart)
				{
					if(secondStart)
						ve = new vertexEdge(second.startEdge.startID, null, first.startEdge.startID, first.startEdge);
					else
						ve = new vertexEdge(second.endEdge.endID, null, first.startEdge.startID, first.startEdge);
					first.startEdge.startEdge = ve;
					first.startEdge = ve;
					first.numEdges ++;
				}
				else
				{
					if(secondStart)
						ve = new vertexEdge(first.endEdge.endID, first.endEdge, second.startEdge.startID, null);
					else
						ve = new vertexEdge(first.endEdge.endID, first.endEdge, second.endEdge.endID, null);
					first.endEdge.endEdge = ve;
					first.endEdge = ve;
					first.numEdges++;
				}
				v1x = vertices[ve.startID][0]- minX;
				v1y = vertices[ve.startID][1]- minY;
				v2x = vertices[ve.endID][0]- minX;
				v2y = vertices[ve.endID][1]- minY;

				c2.strokeStyle = "#ff0000";

				c2.beginPath();
				c2.moveTo(v1x * widthCoef + widthBuff, v1y * heightCoef + heightBuff);
				c2.lineTo(v2x * widthCoef + widthBuff, v2y * heightCoef + heightBuff);
				c2.stroke();


				mergeLines(first, second);
				index = lines.indexOf(second);				//find redundant
				lines.splice(index, 1);						//Remove redundant
			}
			last = lines[0];
			closeVe = new vertexEdge(last.endEdge.endID, last.endEdge, last.startEdge.startID, null);
			last.endEdge.endEdge = closeVe;
			last.endEdge = closeVe;
			last.numEdges++;

			v1x = vertices[closeVe.startID][0]- minX;
			v1y = vertices[closeVe.startID][1]- minY;
			v2x = vertices[closeVe.endID][0]- minX;
			v2y = vertices[closeVe.endID][1]- minY;

			c2.strokeStyle = "#ff0000";

			c2.beginPath();
			c2.moveTo(v1x * widthCoef + widthBuff, v1y * heightCoef + heightBuff);
			c2.lineTo(v2x * widthCoef + widthBuff, v2y * heightCoef + heightBuff);
			c2.stroke();

		});

		$("#drawLinesBtn").click(function()
		{
			drawLines();
		});
		$("#LogLinesBtn").click(function()
		{
			console.log(lines);
		});
	</script>
</html>
